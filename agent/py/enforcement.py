import threading
import time
import boto3
from typing import Any
from common.logger import get_logger
from aggregator.model.integrations.v1.common.inventory import Label
from aggregator.model.integrations.v1.consumer.enforcement import (
    EnforcementPolicy,
    EnforcementPolicyInventory,
)

from agent.resource_reader import AWSResourceReader

LOG = get_logger(module_name=__name__)


class Enforcement:

    def __init__(self, interval: int, get_inventory) -> None:
        self.interval = interval
        self.get_inventory = get_inventory
        self.rules = EnforcementPolicy.model_validate({"policy-revision": 0})
        self.inventory = EnforcementPolicyInventory.model_validate(
            {"dc_inventory_revision": 0, "policy-revision": 0}
        )
        self.lock = threading.Lock()
        self.running = False
        self.worker_thread = None
        self.applied_rules_revision = 0
        self.applied_dc_revision = 0
        self.plan = {}
        
        # FIXME:
        self.boto_session = boto3.Session(region_name='us-east-1')

    def start(self):
        if not self.running:
            LOG.info(f"Starting enforcement worker")
            self.running = True
            self.worker_thread = threading.Thread(target=self.do_work)
            self.worker_thread.daemon = True
            self.worker_thread.start()

    def do_work(self):
        next_run_time = time.time() + self.interval
        while self.running:
            if not self.lock.locked():
                self.lock.acquire()
                try:
                    self.check_policy_revisions()
                except Exception as e:
                    LOG.error(f'Failed to apply plan with {e=}')
                finally:
                    self.lock.release()
                sleep_time = max(0, next_run_time - time.time())
            else:
                LOG.warn(
                    "Enforcement check revision is already working, skipping this cycle."
                )
                sleep_time = max(0, next_run_time - time.time())

            time.sleep(sleep_time)
            next_run_time += self.interval  # Schedule the next run

    def stop(self):
        self.running = False
        if self.worker_thread:
            self.worker_thread.join()
            LOG.info(f"Stop enforcement worker for region")

    def check_policy_revisions(self):
        changed = (
            self.applied_rules_revision < self.inventory.policy_revision
        )

        if changed:
            LOG.info(
                f"changed revisions: rules {self.applied_rules_revision}->{self.inventory.policy_revision}, inventory {self.applied_dc_revision}"
            )

            self.plan = self.make_plan()
            LOG.info(f"{self.plan=}")
            
            self.apply_plan()
            
    def apply_plan(self):
        if self.plan is None:
            return
        
        LOG.info('applying plan')
        
        inventory = self.get_inventory()
        resource_reader = AWSResourceReader(self.boto_session)
        
        deleted_sgs = resource_reader.delete_gc_security_groups()
        
        sgs = {}
        
        for l in self.plan.get('labels', []):
            items = inventory.get_items(l.key, l.value)
            if items is None: 
                LOG.error(f'No vpc associated with {l.key}/{l.value}')
                continue
            
            vpc_id = items[0].entity_data.nics[0].network
            sg = resource_reader.try_create_security_group(
                vpc_id=vpc_id, 
                name = f'gc_{l.key}/{l.value}',
                description = 'generated by gc'
            )
            sgs[f'{l.key}/{l.value}'] = sg
            
            for i in items:
                i_sgs = i.entity_data.os_details.get('security_groups', []) 
                for x in deleted_sgs: 
                    if x in i_sgs: 
                        i_sgs.remove(x)
                
                i_sgs += [sg['GroupId']]
                LOG.info(f'Update instance {i.item_id}, with security groups: {i_sgs}')
                try:
                    resource_reader.update_instance_with_security_groups(
                        i.item_id, 
                        i_sgs
                    )
                except Exception as e:
                    pass
            
        # set ingress rules 
        for rule in self.plan.get('ingress', []): 
            l_src = rule['src']
            l_dst = rule['dst']
            port = rule['port']
            rule_id = rule['description']
            
            sg_src = sgs[f'{l_src.key}/{l_src.value}']
            sg_dst = sgs[f'{l_dst.key}/{l_dst.value}']
            
            resource_reader.create_allow_ingress(
                sg_src, sg_dst, port, rule_id
            )
            
            k = f'{l_src.key}/{l_src.value}->{l_dst.key}/{l_dst.value}:{port}'
            self.plan['enforce'][k] = rule_id
            
            LOG.info(f'Rule: {k} --> {rule_id}')
            
        self.applied_dc_revision = self.inventory.dc_inventory_revision
        self.applied_rules_revision = self.inventory.policy_revision
        LOG.info(f'applied revisions: {self.applied_rules_revision=}, {self.applied_dc_revision=}')

    def make_plan(self) -> dict[str, Any]:
        labels = {}
        ingress = []

        inventory_labels = self.inventory.labels or []
        
        for l in inventory_labels:
            labels[l.label_id] = Label(key=l.key, value=l.value)

        for chain in self.rules.policy_rules:
            for rule in chain.rules:

                if rule.match_dst.match_ports is None:
                    continue

                port = rule.match_dst.match_ports[0]

                src_label_id = rule.match_src.match_labels.include_labels[0][0]
                src_label = labels[src_label_id]

                dst_label_id = rule.match_dst.match_labels.include_labels[0][0]
                dst_label = labels[dst_label_id]

                ingress.append(
                    {
                        "src": src_label,
                        "dst": dst_label,
                        "port": port,
                        "description": str(rule.id),
                    }
                )

        plan = {"labels": [o for o in labels.values()], "ingress": ingress,
                "enforce": {}}
        return plan

    def update_rules(self, json_obj):
        self.rules = EnforcementPolicy.model_validate(json_obj)
        LOG.info(f"Updated rules with revision={self.rules.policy_revision}")
        self.dump_rules()

    def update_inventory(self, json_obj):
        inventory = EnforcementPolicyInventory.model_validate(json_obj)
        if inventory.policy_revision > self.inventory.policy_revision:
            self.inventory = inventory
        else: 
            self.inventory.dc_inventory_revision = inventory.dc_inventory_revision
            LOG.info(f'Update inventory revision only to {self.inventory.dc_inventory_revision}')
        
        LOG.info(
            f"Updated inventory with revision={self.inventory.dc_inventory_revision}"
        )
        self.dump_inventory()

    def dump_rules(self):
        path = "rules.json"
        with open(path, "w") as f:
            json_str = self.rules.model_dump_json(
                exclude_none=True, by_alias=True, indent=4
            )
            f.write(json_str)
            LOG.info(f"Saved rules to {path}, revision={self.rules.policy_revision}")

    def dump_inventory(self):
        path = "dc_inventory.json"
        with open(path, "w") as f:
            json_str = self.inventory.model_dump_json(
                exclude_none=True, by_alias=True, indent=4
            )
            f.write(json_str)
            LOG.info(
                f"Saved inventory to {path}, revision={self.inventory.dc_inventory_revision}"
            )
